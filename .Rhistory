for (i in 1:max(c_eco)) {
# Obtenir les indices des observations dans le cluster i
indices <- which(c_eco == i)
# Stocker les indices dans la liste
indices_clusters[[paste("Cluster", i)]] <- indices
}
# Afficher les indices pour chaque cluster
for (i in 1:length(indices_clusters)) {
cat( names(indices_clusters)[i], ":", indices_clusters[[i]], "\n")
}
# Les indices des clusters que vous avez fournis
cluster_1_indices <- c(1 ,2 ,6 ,7 ,8 ,9, 11 ,14, 16 ,17 ,19 ,20 ,22, 26 ,32 ,34 ,36 ,37 ,38 ,39 ,40, 41 ,43 ,44 ,46, 47 ,49 ,52 ,53, 54 ,56 ,57 ,60 ,61 ,62 ,63 ,65 ,69, 71 ,72 ,74 ,76 ,77 ,78 ,80 ,81 ,87 ,89 ,90 ,92, 93, 94 ,96 ,97 ,99 ,100)
cluster_2_indices <- c(3, 4 ,5 ,10 ,12 ,13 ,15 ,18 ,23, 24, 25, 27, 28, 29, 30 ,31, 33 ,35 ,42 ,45, 48, 50 ,51, 55 ,58, 59, 66, 67, 68, 73, 75, 82, 84, 85, 86, 88, 91, 95)
cluster_3_indices <- c(21, 64, 70, 79, 83, 98)
# Colonne de villes correspondante
v <- villesbruts[,1]  # Remplacez ... par le reste de vos villes
# Associer chaque indice de cluster à la ville correspondante
cluster_1_villes <- v[cluster_1_indices]
cluster_2_villes <- v[cluster_2_indices]
cluster_3_villes <- v[cluster_3_indices]
# Afficher les résultats
cat("Cluster 1 :", cluster_1_villes, "\n")
cat("Cluster 2 :", cluster_2_villes, "\n")
cat("Cluster 3 :", cluster_3_villes, "\n")
install.packages("ClustOfVar")
require(ClustOfVar)
install.packages("ClustOfVar")
require(ClustOfVar)
tree = hclustvar(X.quanti = dataquant)
plot(tree, main = "Dendrogram of ClustOfVar")
install.packages("ClustOfVar")
install.packages("ClustOfVar")
require(ClustOfVar)
tree = hclustvar(X.quanti = villes)
plot(tree, main = "Dendrogram of ClustOfVar")
install.packages("ClustOfVar")
require(ClustOfVar)
tree = hclustvar(X.quanti = dataquant)
plot(tree, main = "Dendrogram of ClustOfVar")
install.packages("ClustOfVar")
install.packages("ClustOfVar")
require(ClustOfVar)
tree = hclustvar(X.quanti = dataquant)
plot((as.dendrogram(tree), main = "Dendrogram of ClustOfVar")
install.packages("ClustOfVar")
require(ClustOfVar)
tree = hclustvar(X.quanti = dataquant)
plot(as.dendrogram(tree), main = "Dendrogram of ClustOfVar")
install.packages("ClustOfVar")
stab = stability(tree, B=100)
stab = stability(tree, B=100)
stab = stability(tree, B=100)
stab
inertie <- sort(tree$height, decreasing = TRUE)
plot(inertie[1:40],
type = "h",
xlab = "Nombre de classes",
ylab = "Dissemblance")
points(c(3), inertie[c(3)], col = c("chartreuse","chartreuse" ,
"chartreuse" ), cex = 2, lwd = 3)
inertie <- sort(tree$height, decreasing = TRUE)
plot(inertie[1:40],
type = "h",
xlab = "Nombre de classes",
ylab = "Dissemblance")
points(c(2,4), inertie[c(2,4)], col = c("chartreuse","chartreuse" ,
"chartreuse" ), cex = 2, lwd = 3)
PV=cutree(tree,2)
PV
PV=cutree(tree,4)
PV
PV=cutree(tree,3)
PV
library(readr)
data_vp <- read_csv("C:/Users/hp/HAX712X_group5_project/data_vp.csv")
View(data_vp)
data_vp
# Create dataframe2 with the specified condition
dataframe2 <- data_vp[data_vp$code_station == "FR50200", ]
# Print the resulting dataframe
print(dataframe2)
View(dataframe2)
# Assuming you have the data in a CSV file named 'your_data.csv'
# You can read the data into a DataFrame using read.csv
df <- data_vp
# Filter rows based on conditions
filtered_data <- df[df$nom_com == "Montpellier" & df$nom_poll == "O3", ]
# Calculate the average of 'valeur'
moyenne <- mean(filtered_data$valeur)
# Print the average
print(moyenne)
View(filtered_data)
# Assuming you have the data in a CSV file named 'your_data.csv'
# You can read the data into a DataFrame using read.csv
df <- data_vp
# Filter rows based on conditions
filtered_data <- df[df$nom_com == "AGDE" & df$nom_poll == "PM10", ]
# Calculate the average of 'valeur'
moyenne <- mean(filtered_data$valeur)
# Print the average
print(moyenne)
View(filtered_data)
# Assuming you have the data in a CSV file named 'your_data.csv'
# You can read the data into a DataFrame using read.csv
df <- data_vp
# Filter rows based on conditions
filtered_data <- df[df$nom_com == "AGDE" & df$nom_poll == "NOX", ]
# Calculate the average of 'valeur'
moyenne <- mean(filtered_data$valeur)
# Print the average
print(moyenne)
library(ClustOfVar)
require(ClustOfVar)
dataquant <- scale(variables_numeric)*sqrt((99) / (100))
library(ClustOfVar)
require(ClustOfVar)
dataquant <- scale(dataquant)*sqrt((99) / (100))
tree = hclustvar( X.quant= dataquant)
plot(tree, main = "Dendrogram of ClustOfVar")
plot(color_branches(tree, main = "Dendrogramme pour les indicateurs")
library(ClustOfVar)
require(ClustOfVar)
dataquant <- scale(dataquant)*sqrt((99) / (100))
tree = hclustvar( X.quant= dataquant)
plot(tree, main = "Dendrogram of ClustOfVar")
plot(color_branches(as.dendrogram(tree), main = "Dendrogramme pour les indicateurs")
library(ClustOfVar)
require(ClustOfVar)
dataquant <- scale(dataquant)*sqrt((99) / (100))
tree = hclustvar( X.quant= dataquant)
plot(as.dendrogram(tree), main = "Dendrogram of ClustOfVar")
plot(color_branches(as.dendrogram(tree), main = "Dendrogramme pour les indicateurs")
library(ClustOfVar)
require(ClustOfVar)
dataquant <- scale(dataquant)*sqrt((99) / (100))
tree = hclustvar( X.quant= dataquant)
plot(as.dendrogram(tree), main = "Dendrogram of ClustOfVar")
#plot inertie
inertie <- sort(tree$height, decreasing = TRUE)
plot(inertie[1:50],main = "clustofvar ",
type = "h",
xlab = "Nombre de classes",
ylab = "Inertie")
#plot inertie
inertie <- sort(tree$height, decreasing = TRUE)
plot(inertie[1:30],main = "clustofvar ",
type = "h",
xlab = "Nombre de classes",
ylab = "Inertie")
inertie <- sort(tree$height, decreasing = TRUE)
plot(inertie[1:40],
type = "h",
xlab = "Nombre de classes",
ylab = "Dissemblance")
points(c(2,4), inertie[c(2,4)], col = c("chartreuse","chartreuse" ,
"chartreuse" ), cex = 2, lwd = 3)
cut_1 = cutree(tree, k=4)
# Convertir l'objet hclust en dendrogram
dend <- as.dendrogram(tree)
cut = cutree(tree, k=3)
# Convertir l'objet hclust en dendrogram
dend <- as.dendrogram(tree)
# Définir les couleurs pour chaque cluster
cluster_colors <- rainbow(3)  # 3 est le nombre de clusters que vous avez spécifié (k=3)
# Colorer les branches du dendrogramme selon les clusters
dend_colored <- dend %>%
assign_values_to_leaves_nodePar("cluster", as.character(cut)) %>%
color_branches(k = 3, groupLabels = as.character(unique(cut)), groupColors = cluster_colors)
# Définir les couleurs pour chaque cluster
cluster_colors <- rainbow(3)  # 3 est le nombre de clusters que vous avez spécifié (k=3)
# Colorer les branches du dendrogramme selon les clusters
dend_colored <- dend %>%
assign_values_to_leaves_nodePar("cluster", as.character(cut))
cut = cutree(tree, k=3)
# Charger la bibliothèque
library(dendextend)
# Dendrogramme des classes
plot(tree, hang = -1, cex = 0.6, main = "Dendrogramme des classes avec l'indice de WARD")
cut = cutree(tree, k=3)
# Charger la bibliothèque
library(dendextend)
# Colorer chaque classe avec une couleur différente
dend <- as.dendrogram(tree)
colored_dend <- color_branches(dend, k = 3)  # Choisir le nombre de classes 3
plot(colored_dend, main = "Dendrogramme des classes: Culture ")
var_quanti_1 = names(cut)[cut == 1]
var_quanti_2 = names(cut)[cut == 2]
var_quanti_3 = names(cut)[cut == 3]
# Afficher les variables dans chaque classe
cat("Variables dans la classe 1:\n", var_quanti_1, "\n\n")
cat("Variables dans la classe 2:\n", var_quanti_2, "\n\n")
cat("Variables dans la classe 3:\n", var_quanti_3, "\n\n")
# Charger la bibliothèque
library(dendextend)
# Colorer chaque classe avec une couleur différente
dend <- as.dendrogram(tree)
colored_dend <- color_branches(dend, k = 3)  # Choisir le nombre de classes 3
plot(colored_dend, main = "Dendrogram of ClustOfVar ")
cut = cutree(tree, k=4)
var_quanti_1 = names(cut)[cut == 1]
var_quanti_2 = names(cut)[cut == 2]
var_quanti_3 = names(cut)[cut == 3]
var_quanti_4 = names(cut)[cut == 4]
# Afficher les variables dans chaque classe
cat("Variables dans la classe 1:\n", var_quanti_1, "\n\n")
cat("Variables dans la classe 2:\n", var_quanti_2, "\n\n")
cat("Variables dans la classe 3:\n", var_quanti_3, "\n\n")
cat("Variables dans la classe 4:\n", var_quanti_4, "\n\n")
cut = cutree(tree, k=4)
var_quanti_1 = names(cut)[cut == 1]
var_quanti_2 = names(cut)[cut == 2]
var_quanti_3 = names(cut)[cut == 3]
# Afficher les variables dans chaque classe
cat("Variables dans la classe 1:\n", var_quanti_1, "\n\n")
cat("Variables dans la classe 2:\n", var_quanti_2, "\n\n")
cat("Variables dans la classe 3:\n", var_quanti_3, "\n\n")
cut = cutree(tree, k=2)
var_quanti_1 = names(cut)[cut == 1]
var_quanti_2 = names(cut)[cut == 2]
# Afficher les variables dans chaque classe
cat("Variables dans la classe 1:\n", var_quanti_1, "\n\n")
cat("Variables dans la classe 2:\n", var_quanti_2, "\n\n")
# Charger la bibliothèque
library(dendextend)
# Colorer chaque classe avec une couleur différente
dend <- as.dendrogram(tree)
colored_dend <- color_branches(dend, k = 2)  # Choisir le nombre de classes 2
plot(colored_dend, main = "Dendrogram of ClustOfVar ")
# Charger la bibliothèque
library(dendextend)
# Colorer chaque classe avec une couleur différente
dend <- as.dendrogram(tree)
colored_dend <- color_branches(dend, k = 4)  # Choisir le nombre de classes 2
plot(colored_dend, main = "Dendrogram of ClustOfVar ")
# Charger la bibliothèque
library(dendextend)
# Colorer chaque classe avec une couleur différente
dend <- as.dendrogram(tree)
colored_dend <- color_branches(dend, k = 3)  # Choisir le nombre de classes 2
plot(colored_dend, main = "Dendrogram of ClustOfVar ")
inertie <- sort(tree$height, decreasing = TRUE)
plot(inertie[1:40],
type = "h",
xlab = "Nombre de classes",
ylab = "Dissemblance")
points(c(2,3,4), inertie[c(2,3,4)], col = c("chartreuse","chartreuse" ,
"chartreuse" ), cex = 2, lwd = 3)
cut = cutree(tree, k=2)
var_quanti_1 = names(cut)[cut == 1]
var_quanti_2 = names(cut)[cut == 2]
var_quanti_2 = names(cut)[cut == 3]
# Afficher les variables dans chaque classe
cat("Variables dans la classe 1:\n", var_quanti_1, "\n\n")
cat("Variables dans la classe 2:\n", var_quanti_2, "\n\n")
cat("Variables dans la classe 2:\n", var_quanti_3, "\n\n")
cut = cutree(tree, k=2)
var_quanti_1 = names(cut)[cut == 1]
var_quanti_2 = names(cut)[cut == 2]
var_quanti_3 = names(cut)[cut == 3]
# Afficher les variables dans chaque classe
cat("Variables dans la classe 1:\n", var_quanti_1, "\n\n")
cat("Variables dans la classe 2:\n", var_quanti_2, "\n\n")
cat("Variables dans la classe 2:\n", var_quanti_3, "\n\n")
cut = cutree(tree, k=2)
var_quanti_1 = names(cut)[cut == 1]
var_quanti_2 = names(cut)[cut == 2]
var_quanti_3 = names(cut)[cut == 3]
# Afficher les variables dans chaque classe
cat("Variables dans la classe 1:\n", var_quanti_1, "\n\n")
cat("Variables dans la classe 2:\n", var_quanti_2, "\n\n")
cat("Variables dans la classe 3:\n", var_quanti_3, "\n\n")
cut = cutree(tree, k=3)
var_quanti_1 = names(cut)[cut == 1]
var_quanti_2 = names(cut)[cut == 2]
var_quanti_3 = names(cut)[cut == 3]
# Afficher les variables dans chaque classe
cat("Variables dans la classe 1:\n", var_quanti_1, "\n\n")
cat("Variables dans la classe 2:\n", var_quanti_2, "\n\n")
cat("Variables dans la classe 3:\n", var_quanti_3, "\n\n")
cut = cutree(tree, k=3)
var_quanti_1 = names(cut)[cut == 1]
var_quanti_2 = names(cut)[cut == 2]
var_quanti_3 = names(cut)[cut == 3]
# Afficher les variables dans chaque classe
cat("Variables dans la classe 1:\n", var_quanti_1, "\n\n")
cat("Variables dans la classe 2:\n", var_quanti_2, "\n\n")
cat("Variables dans la classe 3:\n", var_quanti_3, "\n\n")
cut
# Les indices des clusters que vous avez fournis
cluster_1_indices <- c( 1, 2 ,3 ,4, 6 ,8 ,9, 13, 14, 19 ,21 ,23, 26, 28 ,32 ,34 ,35 ,38 ,41, 43 ,45 ,46, 47, 48 ,49, 51 ,58 ,59 ,63 ,64 ,66 ,67, 68, 69 ,70 ,72, 74 ,75, 77 ,79 ,83 ,90 ,91 ,93, 97, 98, 99)
cluster_2_indices <- c(5, 15, 16, 20, 24, 27, 33, 37 ,42, 50, 52, 54, 55, 56, 57, 61, 62, 76, 78, 86, 88, 89 ,92 ,94 ,96)
cluster_3_indices <- c(7,10, 11 ,12 ,17 ,18 ,22 ,25 ,29 ,30, 31, 36, 39, 40, 44, 53 ,60 ,65 ,71 ,73 ,80, 81, 82, 84, 85, 87, 95, 100 )
# Colonne de villes correspondante
v <- villesbruts[,1]  # Remplacez ... par le reste de vos villes
# Associer chaque indice de cluster à la ville correspondante
cluster_1_villes <- v[cluster_1_indices]
cluster_2_villes <- v[cluster_2_indices]
cluster_3_villes <- v[cluster_3_indices]
# Afficher les résultats
cat("Cluster 1 :", cluster_1_villes, "\n")
cat("Cluster 2 :", cluster_2_villes, "\n")
cat("Cluster 3 :", cluster_3_villes, "\n")
##______________Calcule du R2
R2_PV2_ct = cbind(rep(0 , ncol(data_ct_cr)))
# Liste des colonnes supplémentaires à ajouter
c2 <- c("Musees", "Cinema", "MonumHistoriques", "PretLivres", "RestaurDistingues", "Presse", "Etudiants")
# Créer le nouveau jeu de données data2
data_ct <- dataquant[c2]
data_ct_cr=scale(data_ct)*(sqrt(99/100))
#création de la matrice des distances euclidiennes:
dv_ct=dist(data_ct_cr, method="euclidean")
# CAH avec Ward (vous pouvez essayer plusieurs indices pour juger de la stabilité des résultats):
CAHV_ct = hclust(d=dv_ct, method = "ward.D")
villesbruts <- read.delim("C:/Users/hp/Downloads/villes.csv")
##......................Soustraire la variable 'ville'
dataquant = villesbruts[,2:55]
# Liste des colonnes supplémentaires à ajouter
c2 <- c("Musees", "Cinema", "MonumHistoriques", "PretLivres", "RestaurDistingues", "Presse", "Etudiants")
# Créer le nouveau jeu de données data2
data_ct <- dataquant[c2]
data_ct_cr=scale(data_ct)*(sqrt(99/100))
#création de la matrice des distances euclidiennes:
dv_ct=dist(data_ct_cr, method="euclidean")
# CAH avec Ward (vous pouvez essayer plusieurs indices pour juger de la stabilité des résultats):
CAHV_ct = hclust(d=dv_ct, method = "ward.D")
# Dendrogramme de la hiérarchie indicée:
plot(as.dendrogram(CAHV_ct) ,main = "Dendrogramme Ward : Culture")
#Coupure de l'arbre et fabrication de la variable de classe correspondant à la partition obtenue, par
#exemple k=2 classes:
PV2_ct = cutree(tree = CAHV_ct, k=2)
# Charger la bibliothèque
library(dendextend)
# Dendrogramme des classes
plot(CAHV_ct, hang = -1, cex = 0.6, main = "Dendrogramme des classes avec l'indice de WARD")
# Colorer chaque classe avec une couleur différente
dend <- as.dendrogram(CAHV_ct)
colored_dend <- color_branches(dend, k = 2)  # Choisir le nombre de classes 3
plot(colored_dend, main = "Dendrogramme des classes: Culture ")
##______________Calcule du R2
R2_PV2_ct = cbind(rep(0 , ncol(data_ct_cr)))
for (i in cbind(1:ncol(data_ct_cr))){
R2_PV2_ct[i] = summary(lm(data_ct_cr[,i]~as.factor(PV2_ct)))$r.squared
}
row.names(R2_PV2_ct) = colnames(data_ct_cr)
head(R2_PV2_ct,10)
##______________calcul du R2
R2_PV2_eco = cbind(rep(0 , ncol(data_eco_cr)))
for (i in cbind(1:ncol(data_eco_cr))){
R2_PV2_eco[i] = summary(lm(data_eco_cr[,i]~as.factor(PV2_eco)))$r.squared
}
row.names(R2_PV2_eco) = colnames(data_eco_cr)
head(R2_PV2_eco,10)
##______________calcul du R2
R2_PV2_eco = cbind(rep(0 , ncol(data_eco_cr)))
for (i in cbind(1:ncol(data_eco_cr))){
R2_PV2_eco[i] = summary(lm(data_eco_cr[,i]~as.factor(PV2_eco)))$r.squared
}
row.names(R2_PV2_eco) = colnames(data_eco_cr)
head(R2_PV2_eco,50)
##______________calcul du R2
R2_PV2_eco = cbind(rep(0 , ncol(data_eco_cr)))
for (i in cbind(1:ncol(data_eco_cr))){
R2_PV2_eco[i] = summary(lm(data_eco_cr[,i]~as.factor(PV2_eco)))$r.squared
}
row.names(R2_PV2_eco) = colnames(data_eco_cr)
head(round(R2_PV2_eco,3),50)
PV2_rq = cutree(tree = CAHV_rq, k=2)
PV2_rq = cutree(tree = CAHV_rq, k=2)
inertie_rq <- sort(CAHV_rq$height, decreasing = TRUE)
# Liste des colonnes supplémentaires à ajouter
c <- c("Criminalite", "EvolutionCrimes", "SecuriteRoutiere", "Inondations",
"TerrainsPollues", "UsinesRisques", "MortaliteInfantile",
"MortaliteCancerPoumon", "MortaliteAlcool", "DecesInfarctus",
"TauxSuicide", "MortaliteGlobale", "TailleClassesPrimaires",
"Retard6eme", "Retard3eme", "RetardTerminale")
# Créer le nouveau jeu de données datarisque
data_rq <- dataquant[c]
data_rq_cr=scale(data_rq)*(sqrt(99/100))
#création de la matrice des distances euclidiennes:
dv_rq=dist(data_rq_cr, method="euclidean")
# CAH avec Ward (vous pouvez essayer plusieurs indices pour juger de la stabilité des résultats):
CAHV_rq = hclust(d=dv_rq, method = "ward.D")
# Dendrogramme de la hiérarchie indicée:
plot(as.dendrogram(CAHV_rq) ,main = "Dendrogramme avec la méthode de Ward rq")
rect.hclust(CAHV_rq,2, border ="blue")
#______Dendrogramme des classes
plot(CAHV_rq, hang = -1, cex = 0.6, main =" Dendrogramme des classes avec l'indice de WARD")
rect.hclust(CAHV_rq,2, border ="blue")
PV2_rq = cutree(tree = CAHV_rq, k=2)
##______________calcul du R2
R2_PV2_rq = cbind(rep(0 , ncol(data_rq_cr)))
for (i in cbind(1:ncol(data_rq_cr))){
R2_PV2_rq[i] = summary(lm(data_rq_cr[,i]~as.factor(PV2_rq)))$r.squared
}
row.names(R2_PV2_rq) = colnames(data_rq_cr)
head(R2_PV2_rq,10)
library(ClustOfVar)
# Liste des colonnes supplémentaires à ajouter
c <- c( "Musees", "Cinema", "MonumHistoriques", "PretLivres", "RestaurDistingues", "Presse", "Etudiants")
# Créer le nouveau jeu de données dataculture
data_cult <- dataquant[c]
data_cult_cr=scale(data_cult)*(sqrt(99/100))
#kmeansvar, c, cutreevar,clusterscore,clust_diss, plot.clustab,plot.clustvar, plot.hclustvar
PV2_rq = cutree(tree = CAHV_rq, k=3)
##______________calcul du R2
R2_PV2_rq = cbind(rep(0 , ncol(data_rq_cr)))
for (i in cbind(1:ncol(data_rq_cr))){
R2_PV2_rq[i] = summary(lm(data_rq_cr[,i]~as.factor(PV2_rq)))$r.squared
}
row.names(R2_PV2_rq) = colnames(data_rq_cr)
head(R2_PV2_rq,10)
#Coupure de l'arbre et fabrication de la variable de classe correspondant à  la partition obtenue, en 2 classes car on remarque un énorme saut de 3 à 2 classes:
PV2_eco = cutree(tree = CAHV_eco, k=3)
##______________calcul du R2
R2_PV2_eco = cbind(rep(0 , ncol(data_eco_cr)))
for (i in cbind(1:ncol(data_eco_cr))){
R2_PV2_eco[i] = summary(lm(data_eco_cr[,i]~as.factor(PV2_eco)))$r.squared
}
row.names(R2_PV2_eco) = colnames(data_eco_cr)
head(round(R2_PV2_eco,3),50)
#Transformation d'une variable qualitative en matrice d'indicatrices:
IC2Vil_ct = data.frame(model.matrix(~as.factor(PV2_ct)-1))
mIC2Vil_ct = as.matrix(IC2Vil_ct)
mVil_ct = as.matrix(data_ct_cr)
CentresC2_ct = solve(t(mIC2Vil_ct) %*% mIC2Vil_ct) %*% t(mIC2Vil_ct)%*% mVil_ct
KMV2_ct = kmeans(data_ct_cr, CentresC2_ct)
KMV2_ct$cluster
c_ct = KMV2_ct$cluster
# Initialiser une liste pour stocker les indices pour chaque cluster
indices_clusters <- list()
# Parcourir les clusters
for (i in 1:max(c_ct)) {
# Obtenir les indices des observations dans le cluster i
indices <- which(c_ct == i)
# Stocker les indices dans la liste
indices_clusters[[paste("Cluster", i)]] <- indices
}
# Afficher les indices pour chaque cluster
for (i in 1:length(indices_clusters)) {
cat( names(indices_clusters)[i], ":", indices_clusters[[i]], "\n")
}
R2G_PV2_ct = mean(R2_PV2_ct) # R2 de la partition
R2G_PV2_ct
##______________Calcule du R2
R2_PV2_ct = cbind(rep(0 , ncol(data_ct_cr)))
for (i in cbind(1:ncol(data_ct_cr))){
R2_PV2_ct[i] = summary(lm(data_ct_cr[,i]~as.factor(PV2_ct)))$r.squared
}
row.names(R2_PV2_ct) = colnames(data_ct_cr)
head(R2_PV2_ct,10)
# Assuming you have the data in a CSV file named 'your_data.csv'
# You can read the data into a DataFrame using read.csv
df <- data_vp
villesbruts <- read.delim("C:/Users/hp/Downloads/villes.csv")
View(villesbruts)
install.packages("FactoMineR")
install.packages("FactoMineR")
install.packages("FactoMineR")
library(tidyverse)
library(shiny)
ui <- fluidPage(
titlePanel("Picross Game"),
mainPanel(
tableOutput("picrossGrid"),
actionButton("checkButton", "Check Solution")
)
)
server <- function(input, output, session) {
# Taille du picross
rows <- 5
cols <- 5
# Génération d'une solution aléatoire
solution <- matrix(sample(c(0, 1), rows * cols, replace = TRUE), nrow = rows, ncol = cols)
# Tableau pour stocker l'état actuel du joueur
playerGrid <- reactiveVal(matrix(0, nrow = rows, ncol = cols))
# Affichage du picross
output$picrossGrid <- renderTable({
playerGrid()
}, bordered = TRUE)
# Mise à jour du tableau du joueur lorsqu'une case est cliquée
observeEvent(input$picrossGrid_cell_clicked, {
info <- input$picrossGrid_cell_clicked
i <- info$row
j <- info$col
currentGrid <- playerGrid()
currentGrid[i, j] <- 1 - currentGrid[i, j]  # Inversion 0/1
playerGrid(currentGrid)
})
# Vérification de la solution lorsque le bouton est cliqué
observeEvent(input$checkButton, {
if (identical(playerGrid(), solution)) {
showModal(
modalDialog(
title = "Félicitations!",
"Vous avez résolu le Picross avec succès.",
easyClose = TRUE
)
)
} else {
showModal(
modalDialog(
title = "Échec",
"La solution n'est pas correcte. Réessayez!",
easyClose = TRUE
)
)
}
})
}
shinyApp(ui, server)
runApp('C:/Users/hp/Picross/Picross_test.R')
runApp('C:/Users/hp/Picross/Picross_test.R')
